/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/js/modules/functions.js":
/*!*************************************!*\
  !*** ./src/js/modules/functions.js ***!
  \*************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "burgerMenu": () => (/* binding */ burgerMenu),
/* harmony export */   "ibg": () => (/* binding */ ibg),
/* harmony export */   "initEffect": () => (/* binding */ initEffect),
/* harmony export */   "isMobile": () => (/* binding */ isMobile),
/* harmony export */   "isWebp": () => (/* binding */ isWebp),
/* harmony export */   "prallaxImage": () => (/* binding */ prallaxImage),
/* harmony export */   "responsiveMenu": () => (/* binding */ responsiveMenu)
/* harmony export */ });
const isMobile = {
	Android: function () { return navigator.userAgent.match(/Android/i); },
	BlackBerry: function () { return navigator.userAgent.match(/BlackBerry/i); },
	iOS: function () { return navigator.userAgent.match(/iPhone|iPad|iPod/i); },
	Opera: function () { return navigator.userAgent.match(/Opera Mini/i); },
	Windows: function () { return navigator.userAgent.match(/IEMobile/i); },
	any: function () { return (isMobile.Android() || isMobile.BlackBerry() || isMobile.iOS() || isMobile.Opera() || isMobile.Windows()); }
};

function isWebp() {
	// Проверка поддержки webp
	function testWebP(callback) {
		let webP = new Image();
		webP.src = "https://www.gstatic.com/webp/gallery/1.webp";

		webP.onload = function () {
			callback(webP.height > 0);
		};
		webP.onerror = function () {
			callback(false);
		};
	}
	// Добавление класса _webp или _no-webp для HTML
	testWebP((support) => {
		let className = support === true ? 'webp' : 'no-webp';
		document.documentElement.classList.add(className);
	});
}
function responsiveMenu() {
	const mediaQuerry = window.matchMedia("(max-width: 767.98px)");
	const leftMenu = document.querySelector('.downstage__list.left');
	const rightMenu = document.querySelector('.downstage__list.right');
	const langs = document.querySelector('.header__column-lang');
	const langsContainer = document.querySelector('.header__uppstage');
	const menu = document.querySelector('.header__menu');
	const menuHome = document.querySelectorAll('.downstage__menu');
	if (mediaQuerry.matches) {
		menu.append(leftMenu, rightMenu, langs);
		initEffect();
	} else {
		menuHome[0].append(leftMenu);
		menuHome[1].append(rightMenu);
		langsContainer.prepend(langs);
	}
	mediaQuerry.addEventListener('change', () => {
		if (mediaQuerry.matches) {
			menu.append(leftMenu, rightMenu, langs);
		} else {
			menuHome[0].append(leftMenu);
			menuHome[1].append(rightMenu);
			langsContainer.prepend(langs);
		}
	})
}

function burgerMenu() {
	let burgerButton = document.querySelector('.header__burger');
	let burgerMenu = document.querySelector('.header__menu');
	const langs = document.querySelectorAll('.header__lang');
	if (burgerButton) {
		burgerButton.addEventListener('click', () => {
			burgerButton.classList.toggle('active')
			burgerMenu.classList.toggle('active');
			document.body.classList.toggle('lock');
		});
	}
	langs.forEach(lang => {
		lang.addEventListener('click', (e) => {
			e.preventDefault();
			langs.forEach(langRemove => langRemove.classList.remove('active'));
			lang.classList.add('active');
		});
	})
}


function initEffect() {
	const listWrapper = document.querySelectorAll('[data-lineEffect]');
	// проверяем наличие ссылок и стартуем
	listWrapper.forEach(list => {
		const links = list.querySelectorAll('a');
		const effectSpeed = list.dataset.lineEffect ? list.dataset.lineEffect : 0.4;
		links.length ? startEffect(links, effectSpeed) : null;
	});
}
// создаем внутренние спаны с дубликатами текста и позицианируем над основными
function startEffect(links, effectSpeed) {
	const effectTransition = `transition: transform ${effectSpeed}s ease;`;
	const effectHover = `transform: translate3d(0px, 0%, 0px);`;
	const effectTop = `transform: translate3d(0px, -100%, 0px);`;
	const effectBottom = `transform: translate3d(0px, 100%, 0px);`;
	links.forEach(link => {
		link.insertAdjacentHTML('beforeend', `<span class="hover">
		<span class="hover__text">${link.textContent}</span>
		</span>`);
		if (isMobile.any()) {
			link.addEventListener('touchstart', menulinkActions);
			link.addEventListener('touchend', menulinkActions);
			document.documentElement.classList.add('touch')
		} else {
			document.documentElement.classList.remove('touch')
		}
	});

	// создаем сам эффект
	function menulinkActions(e) {
		const targetLink = e.target;
		const targetFirstSpan = targetLink.querySelector('.hover');
		const targetSecondSpan = targetLink.querySelector('.hover__text');
		const targetLinkHeight = targetLink.offsetHeight / 2;
		const targetLinkPos = e.changedTouches[0].pageY - (targetLink.getBoundingClientRect().top + scrollY);
		if (e.type === 'touchstart') {
			// присваиваем спанам значения трансформа
			targetFirstSpan.style.cssText = targetLinkPos > targetLinkHeight ? effectBottom : effectTop;
			targetSecondSpan.style.cssText = targetLinkPos > targetLinkHeight ? effectTop : effectBottom;
			// // меняем спанам значения трансформа
			setTimeout(() => {
				targetFirstSpan.style.cssText = effectHover + effectTransition;
				targetSecondSpan.style.cssText = effectHover + effectTransition;
			}, 5);
		}
		if (e.type === 'touchend') {
			targetFirstSpan.style.cssText = targetLinkPos > targetLinkHeight ? effectBottom + effectTransition : effectTop + effectTransition;
			targetSecondSpan.style.cssText = targetLinkPos > targetLinkHeight ? effectTop + effectTransition : effectBottom + effectTransition;
		}
	}
}

function ibg() {
	let imgbackround = document.querySelectorAll(".ibg");
	if (imgbackround.length > 0) {
		imgbackround.forEach(imgbg => imgbg.style.backgroundImage = 'url(' + imgbg.querySelector('img').getAttribute('src') + ')');
	}
}

function prallaxImage() {
	const parallaxes = document.querySelectorAll('.parallax > img');
	parallaxes.forEach(parallax => {
		parallax.addEventListener('mousemove', (e) => {
			const parallaxWidth = parallax.offsetWidth;
			const parallaxHeight = parallax.offsetHeight;
			const coordX = e.pageX - parallaxWidth / 2;
			const coordY = e.pageY - parallaxHeight / 2;
			const perOfParallaxMoveX = coordX / parallaxWidth * 100;
			const perOfParallaxMoveY = coordY / parallaxHeight * 100;
			mouseParallax(perOfParallaxMoveX, perOfParallaxMoveY, parallax);
		})
	})
	function mouseParallax(perOfParallaxMoveX, perOfParallaxMoveY, parallax) {
		let positionX = 0;
		let positionY = 0;
		// получаем разницу между текущей и предыдущей позицией
		const distX = perOfParallaxMoveX - positionX;
		const distY = perOfParallaxMoveY - positionY;
		// console.log(`distX - ${perOfParallaxMoveX}`);
		// текущая позиция = предыдущая позиция + разница между текущей и предыдущей позицией  * на коэфф
		positionX = positionX + (distX * 0.05);
		positionY = positionY + (distY * 0.05);
		// Присваиваем значения в транслейт. 40- просто коэффиициент
		parallax.style.transform = `translate(${positionX / 800 * 100}%, ${positionY / 800 * 100}%)`;
	}
}

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
(() => {
/*!***********************!*\
  !*** ./src/js/app.js ***!
  \***********************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _modules_functions_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./modules/functions.js */ "./src/js/modules/functions.js");


;

document.addEventListener('DOMContentLoaded', (e) => {

	_modules_functions_js__WEBPACK_IMPORTED_MODULE_0__.isWebp();
	_modules_functions_js__WEBPACK_IMPORTED_MODULE_0__.responsiveMenu();
	_modules_functions_js__WEBPACK_IMPORTED_MODULE_0__.burgerMenu();
	_modules_functions_js__WEBPACK_IMPORTED_MODULE_0__.ibg();
	_modules_functions_js__WEBPACK_IMPORTED_MODULE_0__.prallaxImage();
})


})();

/******/ })()
;
//# sourceMappingURL=app.min.js.map